"""
backend.py - The part that does the work.
Copyright (C) <2020>  <Adoria298>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

----
"""
# imports
## pip
import grpc
## homemade
### generated by protoc
from uno_pb2 import Player
import uno_pb2_grpc

class Backend():
    def __init__(self, channel, player_name):
        self.stub = uno_pb2_grpc.UnoStub(channel)
        self.me = Player(name=player_name, hand=[], uno_declared=False, score=0)
        self.add_me_to_game()
        self.state = self.stub.RequestStateOfPlay(self.me)
    
    def add_me_to_game(self):
        try:
            self.me = self.stub.AddPlayer(self.me)
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.INTERNAL:
                if e.details() in ("UNKNOWN", "TOO_MANY_PLAYERS", "NAME_TAKEN"):
                    raise ValueError(e.details())
                else:
                    raise e
            else:
                raise e

    def get_player(self):
        return self.me

    def get_state_of_play(self):
        self.state = self.stub.RequestStateOfPlay(self.me)
        return self.state

    def get_hand(self):
        self.get_state_of_play()
        return self.me.hand

    def play_card(self, index):
        card = self.me.hand.pop(index)
        try:
            self.state = self.stub.PlayCard(card)
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.INTERNAL:
                if e.details() in ("UNKNOWN", "CARD_UNPLAYABLE"):
                    self.me.hand.append(card)
                    raise ValueError(e.details())
                else:
                    raise e
            else:
                raise e
        except Exception as e:
            print("The following exception was caught when playing a card.")
            print(e)
            print("Card returned to hand.")
            self.me.hand.append(card)
        return self.state

    def draw_card(self, amount):
        for i in range(amount):
            self.me.hand.append(self.stub.DrawCard(self.me))
    
    def leave_game(self):
        self.me = self.stub.RemovePlayer(self.me)
        return True
    
    @property
    def state(self):
        return self._state

    @state.setter
    def set_state(self, value):
        self._state = value
        for player in self.state.players:
            if player.name == self.me.name:
                self.me = player